Consider the following analogy: _Code_ describes a _computational process_ with a particular _output_ just like a _cooking recipe_ describes the _preparation_ of a particular _meal._

This analogy can help to approach programming from a new angle. It connects three concepts: 1. the intended result or product of 2. some causal process between a limited set of elements and 3. a description of this process that enables its recreation.

|             | programming | cooking     |
|-------------|-------------|-------------|
| result      | output      | meal        |
| process     | execution   | preparation |
| description | code        | recipe      |

In both cases, planning usually starts with the intended result (e.g., "I want crème brûlée"). This enables considerations on processes and elements that generate this result ("What are the ingredients and what do I need to do with them?"). An explicit description of these processes ("Get milk and bring it to a boil.") eventually enables their recreation and with them the deliberate generation of the intended result.

planning:
result -> process -> description

implementation
description -> process -> result

To beginners in cooking and programming alike, the intended result might be more or less clear ("I want Shepherd's Pie" or "I want a program to do my taxes"). For newcomers to programming, however, the difference between computational processes and the code that describes them is rather vague. Even if they know there's a difference, the exact _relation_ between code and executed processes (i.e., what code _means_ to the computer) is often what's missing.

In cooking, on the other hand, even the most inexperienced novice understands not only the difference between the preparation of a meal (i.e., the process) and its recipe (i.e., the description) but they also know the exact relation between both (i.e., what a recipe _means_ to the cook). There is a cultural familiarity with the relation between instructions in a recipe and what actions the cook is supposed to perform according to them. This exposes a forth element in the initial analogy: _The computer interprets code just like a cook interprets a recipe._

|             | programming | cooking |
|-------------|-------------|---------|
| interpreter | computer    | cook    |

This knowledge can be leveraged to help understand the relation between code and computational process. If you know how to describe the preparation of a meal to a cook, then I can show you how to describe _the same thing_ to a computer. You already know what it is supposed to do, so you can start understanding how to describe that to it.

If code describes the preparation of a meal to the computer as if it was the cook, then people _without any prior knowledge of programming_ are able to understand what the program is supposed to do, relate the instructions in code with their according computational processes, and determine if the result is what it is supposed to be.

Procedural Cuisine is a Rosetta Stone to help people that already understand the language of cooking to also understand the language of computers.
